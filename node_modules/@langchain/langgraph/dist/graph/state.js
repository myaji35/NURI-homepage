import { RunnableLambda } from "@langchain/core/runnables";
import { BinaryOperatorAggregate } from "../channels/binop.js";
import { END, Graph } from "./graph.js";
import { LastValue } from "../channels/last_value.js";
import { ChannelWrite } from "../pregel/write.js";
import { Pregel, Channel } from "../pregel/index.js";
import { ChannelRead } from "../pregel/read.js";
export const START = "__start__";
export class StateGraph extends Graph {
    constructor(fields) {
        super();
        Object.defineProperty(this, "channels", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.channels = _getChannels(fields.channels);
    }
    compile(checkpointer) {
        this.validate();
        if (Object.keys(this.nodes).some((key) => key in this.channels)) {
            throw new Error("Cannot use channel names as node names");
        }
        const stateKeys = Object.keys(this.channels);
        const outgoingEdges = {};
        for (const [start, end] of this.edges) {
            if (!outgoingEdges[start]) {
                outgoingEdges[start] = [];
            }
            outgoingEdges[start].push(end !== END ? `${end}:inbox` : END);
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const nodes = {};
        for (const [key, node] of Object.entries(this.nodes)) {
            nodes[key] = Channel.subscribeTo(`${key}:inbox`)
                .pipe(node)
                .pipe(_updateState)
                .pipe(Channel.writeTo(key));
        }
        for (const key of Object.keys(this.nodes)) {
            const outgoing = outgoingEdges[key];
            const edgesKey = `${key}:edges`;
            if (outgoing || this.branches[key]) {
                nodes[edgesKey] = Channel.subscribeTo(key, {
                    tags: ["langsmith:hidden"],
                }).pipe(new ChannelRead(stateKeys));
            }
            if (outgoing) {
                nodes[edgesKey] = nodes[edgesKey].pipe(Channel.writeTo(...outgoing));
            }
            if (this.branches[key]) {
                for (const branch of this.branches[key]) {
                    nodes[edgesKey] = nodes[edgesKey].pipe(new RunnableLambda({
                        func: (i, c) => branch.runnable(i, c),
                    }));
                }
            }
        }
        nodes[START] = Channel.subscribeTo(`${START}:inbox`, {
            tags: ["langsmith:hidden"],
        })
            .pipe(_updateState)
            .pipe(Channel.writeTo(START));
        nodes[`${START}:edges`] = Channel.subscribeTo(START, {
            tags: ["langsmith:hidden"],
        })
            .pipe(new ChannelRead(stateKeys))
            .pipe(Channel.writeTo(`${this.entryPoint}:inbox`));
        return new Pregel({
            nodes,
            channels: this.channels,
            input: `${START}:inbox`,
            output: END,
            hidden: Object.keys(this.nodes)
                .map((node) => `${node}:inbox`)
                .concat(START, stateKeys),
            checkpointer,
        });
    }
}
function _updateState(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
input, options
// eslint-disable-next-line @typescript-eslint/no-explicit-any
) {
    if (!options?.config) {
        throw new Error("Config not found when updating state.");
    }
    ChannelWrite.doWrite(options.config, input);
    return input;
}
function _getChannels(schema) {
    const channels = {};
    for (const [name, values] of Object.entries(schema)) {
        if (values.value) {
            channels[name] = new BinaryOperatorAggregate(values.value, values.default);
        }
        else {
            channels[name] = new LastValue();
        }
    }
    return channels;
}
