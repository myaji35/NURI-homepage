import { RunnableBinding, RunnableEach, RunnableLambda, RunnablePassthrough, _coerceToRunnable, } from "@langchain/core/runnables";
import { CONFIG_KEY_READ } from "../constants.js";
export class ChannelRead extends RunnableLambda {
    constructor(channel) {
        super({
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            func: (input, options) => {
                if ("config" in options) {
                    return this._read(input, options.config);
                }
                return this._read(input, options ?? {});
            },
        });
        Object.defineProperty(this, "lc_graph_name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ChannelRead"
        });
        Object.defineProperty(this, "channel", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.channel = channel;
        this.name = `ChannelRead<${channel}>`;
    }
    get configSpecs() {
        return [
            {
                id: CONFIG_KEY_READ,
                name: CONFIG_KEY_READ,
                description: null,
                default: null,
                // TODO FIX THIS
                annotation: "Callable[[BaseChannel], Any]",
                isShared: true,
                dependencies: null,
            },
        ];
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _read(_, config) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const read = config.configurable?.[CONFIG_KEY_READ];
        if (!read) {
            throw new Error(`Runnable ${this} is not configured with a read function. Make sure to call in the context of a Pregel process`);
        }
        if (Array.isArray(this.channel)) {
            const results = Object.fromEntries(this.channel.map((chan) => [chan, read(chan)]));
            return results;
        }
        return read(this.channel);
    }
}
const defaultRunnableBound = new RunnablePassthrough();
export class ChannelInvoke extends RunnableBinding {
    constructor(fields) {
        const { channels, triggers, when } = fields;
        const mergedTags = [
            ...(fields.config?.tags ? fields.config.tags : []),
            ...(fields.tags ? fields.tags : []),
        ];
        super({
            ...fields,
            bound: fields.bound ??
                defaultRunnableBound,
            config: {
                ...(fields.config ? fields.config : {}),
                tags: mergedTags,
            },
        });
        Object.defineProperty(this, "lc_graph_name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ChannelInvoke"
        });
        Object.defineProperty(this, "channels", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "triggers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        Object.defineProperty(this, "when", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.channels = channels;
        this.triggers = triggers;
        this.when = when;
    }
    join(channels) {
        if (typeof this.channels !== "object") {
            throw new Error("all channels must be named when using .join()");
        }
        return new ChannelInvoke({
            channels: {
                ...this.channels,
                ...Object.fromEntries(channels.map((chan) => [chan, chan])),
            },
            triggers: this.triggers,
            when: this.when,
            bound: this.bound,
            kwargs: this.kwargs,
            config: this.config,
        });
    }
    pipe(coerceable) {
        if (this.bound === defaultRunnableBound) {
            return new ChannelInvoke({
                channels: this.channels,
                triggers: this.triggers,
                when: this.when,
                bound: _coerceToRunnable(coerceable),
                config: this.config,
                kwargs: this.kwargs,
            });
        }
        else {
            return new ChannelInvoke({
                channels: this.channels,
                triggers: this.triggers,
                when: this.when,
                bound: this.bound.pipe(coerceable),
                config: this.config,
                kwargs: this.kwargs,
            });
        }
    }
}
export class ChannelBatch extends RunnableEach {
    constructor(fields) {
        super({
            ...fields,
            bound: fields.bound ?? defaultRunnableBound,
        });
        Object.defineProperty(this, "lc_graph_name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ChannelBatch"
        });
        Object.defineProperty(this, "channel", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "key", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.channel = fields.channel;
        this.key = fields.key;
    }
    join(channels) {
        if (!this.key) {
            throw new Error(`Cannot join() additional channels without a key.\nPass a key arg to Channel.subscribeToEach().`);
        }
        const channelsMap = {};
        for (const chan of channels) {
            channelsMap[chan] = new ChannelRead(chan);
        }
        const joiner = RunnablePassthrough.assign({ ...channelsMap });
        if (this.bound === defaultRunnableBound) {
            return new ChannelBatch({
                channel: this.channel,
                key: this.key,
                bound: joiner,
            });
        }
        else {
            return new ChannelBatch({
                channel: this.channel,
                key: this.key,
                bound: this.bound.pipe(joiner),
            });
        }
    }
    // @ts-expect-error @TODO: fix later
    pipe(coerceable) {
        if (this.bound === defaultRunnableBound) {
            return new ChannelBatch({
                channel: this.channel,
                key: this.key,
                bound: _coerceToRunnable(coerceable),
            });
        }
        else {
            // Delegate to `or` in `this.bound`
            return new ChannelBatch({
                channel: this.channel,
                key: this.key,
                bound: this.bound.pipe(coerceable),
            });
        }
    }
}
