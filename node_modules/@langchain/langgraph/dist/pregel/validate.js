import { LastValue } from "../channels/last_value.js";
import { ReservedChannels } from "./reserved.js";
export function validateGraph({ nodes, channels, input, output, hidden, interrupt, }) {
    const newChannels = channels;
    const subscribedChannels = new Set();
    for (const node of Object.values(nodes)) {
        if (node.lc_graph_name === "ChannelInvoke" && "channels" in node) {
            if (typeof node.channels === "string") {
                subscribedChannels.add(node.channels);
            }
            else {
                Object.values(node.channels).map((channel) => subscribedChannels.add(channel));
            }
        }
        else if (node.lc_graph_name === "ChannelBatch" && "channel" in node) {
            subscribedChannels.add(node.channel);
        }
        else {
            console.error(node);
            throw new Error(`Invalid node type: ${JSON.stringify(node, null, 2)}, expected Channel.subscribeTo() or Channel.subscribe_to_each()`);
        }
    }
    for (const chan of [...subscribedChannels]) {
        if (!(chan in newChannels)) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            newChannels[chan] = new LastValue();
        }
    }
    if (typeof input === "string") {
        if (!(input in newChannels)) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            newChannels[input] = new LastValue();
        }
        if (!subscribedChannels.has(input)) {
            throw new Error(`Input channel ${input} is not subscribed to by any node.`);
        }
    }
    else {
        for (const chan of input) {
            if (!(chan in newChannels)) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                newChannels[chan] = new LastValue();
            }
        }
        if (input.every((chan) => !subscribedChannels.has(chan))) {
            throw new Error(`None of the input channels ${input} are subscribed to by any node`);
        }
    }
    if (typeof output === "string") {
        if (!(output in newChannels)) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            newChannels[output] = new LastValue();
        }
    }
    else {
        for (const chan of output) {
            if (!(chan in newChannels)) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                newChannels[chan] = new LastValue();
            }
        }
    }
    for (const chan in ReservedChannels) {
        if (!(chan in newChannels)) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            newChannels[chan] = new LastValue();
        }
    }
    validateKeys(hidden, newChannels);
    validateKeys(interrupt, newChannels);
}
export function validateKeys(keys, channels) {
    if (Array.isArray(keys)) {
        for (const key of keys) {
            if (!(key in channels)) {
                throw new Error(`Key ${key} not found in channels`);
            }
        }
    }
    else {
        if (!(keys in channels)) {
            throw new Error(`Key ${keys} not found in channels`);
        }
    }
}
